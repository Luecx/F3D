#include "LoadingThread.h"

LoadingThread::LoadingThread() {
    worker = std::thread(&LoadingThread::process_operations, this);
}

LoadingThread::~LoadingThread() {
    {
        std::unique_lock<std::mutex> lock(queue_mutex);
        stop_thread = true;
    }
    queue_cv.notify_all();
    worker.join();
}

void LoadingThread::queue_operation(const Operation& operation) {
    {
        std::unique_lock<std::mutex> lock(queue_mutex);
        operations_queue.push(operation);
    }
    queue_cv.notify_one();
}

void LoadingThread::process_operations() {
    while (true) {
        Operation op;

        {
            std::unique_lock<std::mutex> lock(queue_mutex);
            queue_cv.wait(lock, [this] { return !operations_queue.empty() || stop_thread; });

            if (stop_thread && operations_queue.empty()) {
                break;
            }

            op = operations_queue.front();
            operations_queue.pop();
        }

        op.data->operator()(op.state, op.type);
    }
}
#ifndef LOADINGTHREAD_H
#define LOADINGTHREAD_H

#include "ResourceData.h"
#include <queue>
#include <mutex>
#include <condition_variable>
#include <thread>

struct Operation {
    std::shared_ptr<ResourceData> data;
    Type type;
    State state;
};

class LoadingThread {
    private:
    std::queue<Operation> operations_queue;
    std::mutex queue_mutex;
    std::condition_variable queue_cv;
    std::thread worker;
    bool stop_thread = false;

    void process_operations();

    public:
    LoadingThread();
    ~LoadingThread();

    void queue_operation(const Operation& operation);
};

#endif // LOADINGTHREAD_H
#include "MeshData.h"

bool MeshData::load_cpu_specific() {
    // Mesh-specific CPU loading logic here
    return true;
}

bool MeshData::load_gpu_specific() {
    // Mesh-specific GPU loading logic here
    return true;
}

bool MeshData::unload_cpu_specific() {
    // Mesh-specific CPU unloading logic here
    return true;
}

bool MeshData::unload_gpu_specific() {
    // Mesh-specific GPU unloading logic here
    return true;
}
#ifndef MESHDATA_H
#define MESHDATA_H

#include "ResourceData.h"

struct MeshData : public ResourceData {
    using ResourceData::ResourceData;

    bool load_cpu_specific() override;
    bool load_gpu_specific() override;
    bool unload_cpu_specific() override;
    bool unload_gpu_specific() override;
};

#endif // MESHDATA_H
#include "ResourceData.h"
#include "ResourceManager.h"

ResourceData::ResourceData(const std::string& path)
    : path(path) {}

void ResourceData::set_manager(ResourceManager* manager) {
    this->manager = manager;
}

bool ResourceData::load_cpu() {
    if (loaded_cpu) {
        return false;
    }
    bool result = load_cpu_specific();
    if (result) {
        loaded_cpu = true;
    }
    return result;
}

bool ResourceData::load_gpu() {
    if (loaded_gpu) {
        return false;
    }
    if (!loaded_cpu) {
        if (!load_cpu()) {
            return false;
        }
    }
    bool result = load_gpu_specific();
    if (result) {
        loaded_gpu = true;
    }
    return result;
}

bool ResourceData::unload_cpu() {
    if (!loaded_cpu) {
        return false;
    }
    bool result = unload_cpu_specific();
    if (result) {
        loaded_cpu = false;
    }
    return result;
}

bool ResourceData::unload_gpu() {
    if (!loaded_gpu) {
        return false;
    }
    bool result = unload_gpu_specific();
    if (result) {
        loaded_gpu = false;
    }
    return result;
}

bool ResourceData::operator()(State state, Type type) {
    switch (type) {
        case LOAD:
            if (state == CPU) {
                return load_cpu();
            } else if (state == GPU) {
                return load_gpu();
            }
            break;
        case UNLOAD:
            if (state == CPU) {
                return unload_cpu();
            } else if (state == GPU) {
                return unload_gpu();
            }
            break;
    }
    return false;
}

void ResourceData::load(State state) {
#ifdef F3D_PARALLEL_LOADING
    if (manager) {
        manager->queue_load_operation(shared_from_this(), state);
    } else {
#endif
        operator()(state, LOAD);
#ifdef F3D_PARALLEL_LOADING
    }
#endif
}

void ResourceData::unload(State state) {
#ifdef F3D_PARALLEL_LOADING
    if (manager) {
        manager->queue_unload_operation(shared_from_this(), state);
    } else {
#endif
        operator()(state, UNLOAD);
#ifdef F3D_PARALLEL_LOADING
    }
#endif
}
#ifndef RESOURCEDATA_H
#define RESOURCEDATA_H

#include <ecs.h>
#include <memory>
#include <string>

enum Type { LOAD, UNLOAD };
enum State { CPU, GPU };

class ResourceManager;

struct ResourceData : public std::enable_shared_from_this<ResourceData> {
    private:
    std::string path;
    ecs::ID id;
    ResourceManager* manager = nullptr;

    bool loaded_cpu = false;
    bool loaded_gpu = false;

    public:
    ResourceData(const std::string& path);

    void set_manager(ResourceManager* manager);

    protected:
    virtual bool load_cpu_specific() = 0;
    virtual bool load_gpu_specific() = 0;
    virtual bool unload_cpu_specific() = 0;
    virtual bool unload_gpu_specific() = 0;

    bool load_cpu();
    bool load_gpu();
    bool unload_cpu();
    bool unload_gpu();

    public:
    bool operator()(State state, Type type);

    void load(State state);
    void unload(State state);
};

#endif // RESOURCEDATA_H
#include "ResourceManager.h"

#ifdef F3D_PARALLEL_LOADING
void ResourceManager::queue_load_operation(const std::shared_ptr<ResourceData>& data, State state) {
    loading_thread.queue_operation({data, LOAD, state});
}

void ResourceManager::queue_unload_operation(const std::shared_ptr<ResourceData>& data, State state) {
    loading_thread.queue_operation({data, UNLOAD, state});
}


#endif
#ifndef RESOURCEMANAGER_H
#define RESOURCEMANAGER_H

#define F3D_PARALLEL_LOADING

#include "LoadingThread.h"
#include <unordered_map>
#include <vector>

class ResourceManager {
    std::unordered_map<ecs::Hash, std::vector<std::shared_ptr<ResourceData>>> resources;
#ifdef F3D_PARALLEL_LOADING
    LoadingThread loading_thread;
#endif

    public:
    ResourceManager() = default;
    ~ResourceManager() = default;

    template<typename DATA>
    std::shared_ptr<DATA> add(const std::string& path);

#ifdef F3D_PARALLEL_LOADING
    void queue_load_operation(const std::shared_ptr<ResourceData>& data, State state);
    void queue_unload_operation(const std::shared_ptr<ResourceData>& data, State state);
#endif
};

#include "ResourceManager.tpp"

#endif // RESOURCEMANAGER_H
#ifndef RESOURCEMANAGER_TPP
#define RESOURCEMANAGER_TPP

#include "ResourceManager.h"

template<typename DATA>
std::shared_ptr<DATA> ResourceManager::add(const std::string& path) {
    auto data = std::make_shared<DATA>(path);
    data->set_manager(this);
    auto hash = ecs::get_type_hash<DATA>();
    resources[hash].push_back(data);
    return data;
}

#endif // RESOURCEMANAGER_TPP
