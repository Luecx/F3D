#include "LogOutput.h"

LogOutput::LogOutput(int levels) : levels_(levels) {}

bool LogOutput::should_log(int level) const {
    return (levels_ & level) != 0;
}

FileOutput::FileOutput(std::shared_ptr<std::ofstream> file_stream, int levels)
    : LogOutput(levels), file_stream_(file_stream) {}

void FileOutput::log(int level, const std::string& message) const {
    std::lock_guard<std::mutex> lock(mtx_);
    if (file_stream_->is_open()) {
        *file_stream_ << message << std::endl;
    }
}

StreamOutput::StreamOutput(std::ostream& stream, int levels)
    : LogOutput(levels), stream_(stream) {}

void StreamOutput::log(int level, const std::string& message) const {
    std::lock_guard<std::mutex> lock(mtx_);
    stream_ << message << std::endl;
}
#ifndef LOGOUTPUT_H
#define LOGOUTPUT_H

#include <string>
#include <fstream>
#include <iostream>
#include <memory>
#include <mutex>

class LogOutput {
    public:
    LogOutput(int levels);
    virtual ~LogOutput() = default;

    bool should_log(int level) const;
    virtual void log(int level, const std::string& message) const = 0;

    protected:
    int levels_;
};

class FileOutput : public LogOutput {
    public:
    FileOutput(std::shared_ptr<std::ofstream> file_stream, int levels);
    void log(int level, const std::string& message) const override;

    private:
    std::shared_ptr<std::ofstream> file_stream_;
    mutable std::mutex mtx_;
};

class StreamOutput : public LogOutput {
    public:
    StreamOutput(std::ostream& stream, int levels);
    void log(int level, const std::string& message) const override;

    private:
    std::ostream& stream_;
    mutable std::mutex mtx_;
};

#endif // LOGOUTPUT_H
#include "Logger.h"
#include <ctime>
#include <sstream>
#include <stdexcept>

std::shared_ptr<std::ofstream> FileManager::get_file_stream(const std::string& filename) {
    std::lock_guard<std::mutex> lock(mtx_);
    if (file_streams_.find(filename) == file_streams_.end()) {
        file_streams_[filename] = std::make_shared<std::ofstream>(filename, std::ios::app);
    }
    return file_streams_[filename];
}

Logger::Logger() : use_timestamp_(false), current_channel_(-1), file_manager_(std::make_shared<FileManager>()) {}

Logger& Logger::channel(int channel_id) {
    if (channel_id < 0 || channel_id >= 16) {
        throw std::invalid_argument("Channel ID must be between 0 and 15");
    }
    current_channel_ = channel_id;
    if (channels_.find(channel_id) == channels_.end()) {
        channels_[channel_id] = std::make_shared<Channel>();
    }
    return *this;
}

Logger& Logger::file_output(const std::string& filename, int levels) {
    if (current_channel_ < 0) {
        throw std::logic_error("No channel selected");
    }
    auto file_stream = file_manager_->get_file_stream(filename);
    channels_[current_channel_]->outputs.emplace_back(std::make_shared<FileOutput>(file_stream, levels));
    return *this;
}

Logger& Logger::cout(int levels) {
    if (current_channel_ < 0) {
        throw std::logic_error("No channel selected");
    }
    channels_[current_channel_]->outputs.emplace_back(std::make_shared<StreamOutput>(std::cout, levels));
    return *this;
}

Logger& Logger::cerr(int levels) {
    if (current_channel_ < 0) {
        throw std::logic_error("No channel selected");
    }
    channels_[current_channel_]->outputs.emplace_back(std::make_shared<StreamOutput>(std::cerr, levels));
    return *this;
}

Logger& Logger::timestamp() {
    use_timestamp_ = true;
    return *this;
}

void Logger::log(int channel_id, int level, const std::string& message) const {
    if (channels_.find(channel_id) != channels_.end()) {
        const auto& channel = channels_.at(channel_id);
        for (const auto& output : channel->outputs) {
            if (output->should_log(level)) {
                output->log(level, format_message(level, message));
            }
        }
    }
}

std::string Logger::format_message(int level, const std::string& message) const {
    std::stringstream ss;
    if (use_timestamp_) {
        ss << current_timestamp() << " ";
    }
    ss << level_to_string(level) << ": " << message;
    return ss.str();
}

std::string Logger::current_timestamp() const {
    std::time_t now = std::time(nullptr);
    char buf[100];
    std::strftime(buf, sizeof(buf), "%Y-%m-%d %H:%M:%S", std::localtime(&now));
    return buf;
}

std::string Logger::level_to_string(int level) const {
    switch (level) {
        case INFO: return "INFO";
        case WARNING: return "WARNING";
        case ERROR: return "ERROR";
        case DEBUG: return "DEBUG";
        default: return "UNKNOWN";
    }
}
#ifndef LOGGER_H
#define LOGGER_H

#include <string>
#include <map>
#include <vector>
#include <memory>
#include <mutex>
#include "LogOutput.h"

enum LogLevel {
    INFO = 1 << 0,
    WARNING = 1 << 1,
    ERROR = 1 << 2,
    DEBUG = 1 << 3,
    ALL = INFO | WARNING | ERROR | DEBUG
};

class FileManager {
    public:
    std::shared_ptr<std::ofstream> get_file_stream(const std::string& filename);

    private:
    std::map<std::string, std::shared_ptr<std::ofstream>> file_streams_;
    std::mutex mtx_;
};

class Logger {
    public:
    Logger();

    Logger& channel(int channel_id);
    Logger& file_output(const std::string& filename, int levels);
    Logger& cout(int levels);
    Logger& cerr(int levels);
    Logger& timestamp();

    void log(int channel_id, int level, const std::string& message) const;

    private:
    struct Channel {
        std::vector<std::shared_ptr<LogOutput>> outputs;
    };

    std::string format_message(int level, const std::string& message) const;
    std::string current_timestamp() const;
    std::string level_to_string(int level) const;

    std::map<int, std::shared_ptr<Channel>> channels_;
    bool use_timestamp_;
    int current_channel_;
    std::shared_ptr<FileManager> file_manager_;
};

#endif // LOGGER_H
#include "logging.h"

namespace logging {
std::shared_ptr<Logger> logger;

void set_logger(const Logger& log) {
    logger = std::make_shared<Logger>(log);
}

void log(int channel_id, int level, const std::string& message) {
    if (logger) {
        logger->log(channel_id, level, message);
    }
}
}
#ifndef LOGGING_H
#define LOGGING_H

#include <memory>
#include "Logger.h"

namespace logging {
extern std::shared_ptr<Logger> logger;

void set_logger(const Logger& log);
void log(int channel_id, int level, const std::string& message);
}

#endif // LOGGING_H
